1.对于内置类型而言，new仅仅是分配内存，除非后面显示加(),相当于调用它的构造函数，对于自定义类型而言，只要一调用new，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化，即使后面没有加().

2.接口：        类似于类（只有功能声明的类），只提供虚函数方法。被继承时，继承类需要独自实现其所有方法。接口是行为的抽象。抽象类，自下而上；接口，自上而下。

3.a[4]={1,2,3,4}; &a是数组指针，a是数组首地址。

4.(int&)a将a的引用强制转换为整型,意思是a所在的内存，本来定义的时候为float类型并初始为1.0f，但现在我要按int类型解释这段内存（也就是说a所在的内存地址中的数据本来是按float型存储表示的，你非要按int型来解释不可）。
1.0f   在内存中的存储为
0   011   1111   1   000   0000   0000   0000   0000   0000.
把他按整型数解释为2^29+2^28+2^27+2^26+2^25+2^24+2^23=1065353216

5.内联说明（inline specification）对于编译器来说只是一个建议，编译器可以选择忽略这个建议。←如果内联函数太长就忽略了，补充一下哈
如果内联函数定义在调用函数的后面，则编译器会将其当作普通函数调用来看，并不会直接插入到调用处。

6.取余操作对浮点数和double双精度数无意义

7.
一、重载（overload）：
       特征： 函数名相同 、函数参数不同、 必须位于同一个域（类）中；
二、覆盖（override）：
       特征： 函数名相同 、函数参数相同、 分别位于派生类和基类中、virtual（虚函数）；
三、隐藏（hide）：
       即：派生类中函数隐藏（屏蔽）了基类中的同名函数。
       情形1： 函数名相同、 函数参数相同、 分别位于派生类和基类中、virtual -- 为 覆盖；
       情形2： 函数名相同、 函数参数相同、 分别位于派生类和基类中   -- 为 隐藏；（即跟覆盖的区别是基类中函数是否为虚函数）
       情形3 ： 函数名相同、 函数参数不同、 分别位于派生类和基类中   -- 为 隐藏；（即与重载的区别是两个函数是否在同一个域（类）中）

8.静态变量在类外初始化要加上：：，同时不能再加static关键字了

9.可见结构体中成员的书写顺序对结构体大小的影响还是很大的，一个好的建议是，按照数据类型由小到大的顺序进行书写

10.
32位编译器：32位系统下指针占用4字节
      char ：1个字节
      char（即指针变量） 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
      short int  2个字节
      int：  4个字节
      unsigned int  4个字节
      float  4个字节
      double   8个字节
      long   4个字节
      long long  8个字节
      unsigned long  4个字节
64位编译器：64位系统下指针占用8字节
      char ：1个字节
      char(即指针变量) 8个字节
      short int  2个字节
      int：  4个字节
      unsigned int  4个字节
      float  4个字节
      double   8个字节
      long   8个字节
      long long  8个字节
      unsigned long  8个字节

11.char data[0]; 柔性数组,它只能放在结构体末尾,是申明一个长度为0的数组，就可以使得这个结构体是可变长的。

